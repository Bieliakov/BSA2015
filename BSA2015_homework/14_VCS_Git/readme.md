Hi there! This is my task dedicated to version control systems. 

1. Работа с историей изменений. 
Написать команды:
1.1 которая выводит сообщения и автора всех коммитов из ветки develop-feature1, которые сделаны за последние 3 часа и которых нет в родительских ветках (develop, master). Сортировка по дате, первые более новые.

git log develop-feature1 --not develop --date-order --pretty=format:"%an: %s" --since=3.hours

1.2 выводит для каждого коммита из веток master, develop, в сообщении которых есть упоминание заданного номера задачи (допустим задачи 231), его сообщение, автора и дату. Сортировка по дате, первые более новые.

git log master develop --grep=231 --pretty=format:"%s %an %ad" --date-order

2. “Избирательное слияние”. 
Дано: После слияния ветки develop-feature1 в develop, вы продолжили работать в ветке develop-feature1, а develop отдали на тестирование, потом исправили ошибку и закоммитили исправление в develop-feature1, сделали push. Через какое-то время тим лид говорит, что это критический фикс, и надо включить его в develop. Вы делаете pull в ветке develop-feature1 и оказывается, что ваш коллега сделал еще 3 коммита после вашего, и они не стабильные, поэтому не должны быть включены в develop. 
Задание: как добавить в develop только ваш коммит, но чтобы 3 коммита после него в develop не попали?

ОТВЕТ: необходимо, находясь на ветке develop (git checkout develop) выполнить комманду git cherry-pick <commit_hash>
, где <commit_hash> - хэш коммита с хотфиксом, который хотим добавить в ветку develop.

3. “Исправление ошибок”.
Дано: Вы начали работу над новой фичей и создали от develop дочернюю ветку develop-feature3.
Сделали там несколько коммитов, и синхронизировались с сервером - все ваши изменения теперь в develop-feature3 на сервере. И тут вы вспомнили, что тим лид строго настрого сказал, что сообщение каждого коммита должно быть форматировано определенным образом (см. примечание п.0) и обязательно содержать номер задачи. А вы об этом забыли и теперь на сервере лежит ветка develop-feature1с “плохими” сообщениями. Задание: Предложите вариант, как наиболее просто исправить ситуацию, чтобы тим лид не увидел ваш промах.

ОТВЕТ:

1) Первым делом я посмотрю какие сообщения коммитов я хочу менять. Посмотреть ветви коммитов можно коммандой:

git log --oneline --graph --all --decorate
- вывод в одну строку (сообщения и сокращенного хеша) информации о коммитах из всех веток с визуальным отображением ветвления, названий веток и соответствий локальных веток проекта с ветками репозитория на гитхабе.

2) далее выполнить комманду git rebase -i <commit_hash>
, где <commit_hash> - хэш коммита, до которого (не включая его самого), необходимо сделать изменение сообщений.
(или комманда git rebase -i HEAD~2, в нашем случае).
-i - сокращения для --interactive - позволяет редактировать коммиты до их "перебазировки"

3) Далее откроется редактор, установленный по умолчанию, с перечнем коммитов.
Для каждого коммита, сообщение которого я хочу изменить, необходимо заменить слова pick на reword (ниже перечня коммитов, в открывшемся файле есть объяснение этих ключевых слов). Сохранить и закрыть окно редактора.

4) Для кожного коммита поочередно, открывается редактор, где мы меняем сообщение, сохраняемся и закрываем окно редактора (то есть, в нашем случае редактор с сообщением откроется дважды).

5) Проверяем обновление наших сообщений коммандой из первого пункта
git log --oneline --graph --all --decorate

6) Заливаем изменения на удалённый репозиторий коммандой 
git push origin develop-feature1 --force-with-lease
параметр --force-with-lease - позволяет обновить репозиторий только в том случае, если репозиторий находиться в ожидаемом состоянии, т.е. никто другой его не обновил. Лучше использовать вместо --force.


